## javarush-cryptoanalyser - Шифрование и расшифровка текстовых файлов
### Программа имеет 2 режима работы:
1. Шифровка текста.
2. Расшифровка текста.  
    2.1 Расшифровка с помощью известного ключа  
    2.2 Расшифровка методом Brute force

----

### 1.Шифрование
Для шифрования текста запустите скрипт с параметрами: "enсript srcPath dstPath key", где: 
1. `enсript` - сообщает программе о том, что будет производиться шифровка текста.
2. `srcPath` - указывает на путь к исходному файлу (путь должен быть относительным).
3. `dstPath` - указывает на путь, куда будет записан результат (путь должен быть относительным).
4. `key` - ключ-шифр, уникальное число. Может быть от 1 до 123

Пример запуска шифрования:  
```java -jar javarush-cryptoanalyser encript src.txt dst.txt 3```  

Файл `src.txt` с исходным текстом должен существовать, иначе будет выброшено исключение.  
Файл назначения `dst.txt`, куда будет записан результат шифрования будет создан, если не существует.

**ВНИМАНИЕ!**  
Все файлы должны иметь расширение **txt** Иначе будет выброшено исключение.

При удачном шифровании скрипт вернет сообщение "Зашифровано".
Если произошла ошибка в шифровании, скрипт вернет описание ошибки.

----
### 2.Расшифровка  
   
#### 2.1 Расшифровка с помощью известного ключа
Для расшифровки текста с известным ключом запустите скрипт с параметрами: "deсript srcPath dstPath key", где:
1. `decript` - сообщает программе о том, что быдет производиться расшифровка текста.
2. `srcPath` - указывает на путь к исходному файлу (путь должен быть относительным).
3. `dstPath` - указывает на путь, куда будет записан результат (путь должен быть относительным).
4. `key` - ключ-шифр, уникальное число. Может быть от 1 до 123 (расшифровка с помощью ключа)

Пример расшифровки с использованием ключа:  
```java -jar javarush-cryptoanalyser decript src.txt dst.txt 3```

Файл `src.txt` с исходным текстом должен существовать, иначе будет выброшено исключение.  
Файл назначения `dst.txt`, куда будет записан результат шифрования будет создан, если не существует.

**ВНИМАНИЕ!**  
Все файлы должны иметь расширение **txt** Иначе будет выброшено исключение.

При удачной расшифровке скрипт вернет сообщение "Расшифровано".
Если произошла ошибка при расшифровке, скрипт вернет описание ошибки.

----

#### 2.2 Расшифровка c помощью метода Brute force:
Для расшифровки текста запустите скрипт с параметрами: "bruteforce srcPath dstPath", где:
1. `decript` - сообщает программе о том, что будет производиться расшифровка текста.
2. `srcPath` - указывает на путь к исходному файлу (путь должен быть относительным).

Пример расшифровки с использованием ключа:  
```java -jar javarush-cryptoanalyser bruteforce src.txt dst.txt```

Файл `src.txt` с исходным текстом должен существовать, иначе будет выброшено исключение.  
Файл назначения `dst.txt`, куда будет записан результат шифрования будет создан, если не существует.

**ВНИМАНИЕ!**  
Все файлы должны иметь расширение **txt** Иначе будет выброшено исключение.

При удачной расшифровки скрипт вернет сообщение "**Расшифровано**".
Если произошла ошибка при расшифровке, скрипт вернет описание ошибки.

---

###Пояснения работы алгоритма расшифровки методом Brute Force.

Если в расшифровке с помощью известного ключа мы использовали класс `FileReader` и считывали данные в массив типа `char`  
т.к. слова нам были не важны и мы искали соответствующий символ со сдвигом по ключу, то в методе Brute Force необходимо 
считывать слова, поэтому было принято решение использовать класс `BufferedReader`.

1. Сначала запускаем класс **startDecript**.  
2. Вызывается класс поиска ключа **searchKey**.  
3. В классе **searchKey** запускаем цикл, который перебирает в цикле все возможные варианты ключей.  
4. В цикле перебора ключей декодируется текст из исходного файла построчно с помощью метода **getDecriptLine**.
5. Далее декодированная строка разбивается на слова и сравниваются с самыми популярными словами в методе **isContaintWord**,  
   которые находятся в файле **ExampleText.txt**. в методе **isContaintWord** исходное слово мы отрезаем по длине не больше 6 символов  
   это увеличивает шансы на сопадение слова, т.к. окончания у одного слова могут быть разные.  
7. После этого подсчитывается количество совпадений слов по каждому возможному ключу и записывается в HashMap.  
8. В HashMap ключ это возможный ключ для расшифровки, значение это количество найденных совпадений по ключу.  
9. Метод **getKey** возвращает ключ из HashMap, с наибольшим количеством совпадений, это и будет ключ для расшифровки текста.  
10. Далее с помощью найденного ключа построчно расшифровываем текст и записываем в файл.  

>ВНИМАНИЕ!  
> Файл с именем **ExampleText.txt** обязательно должен существовать с массивом самых популярных слов разделенных запятой.  
> В предложенном файле находится 5000 слов английского текста и 5000 слов русского текста.
 
*Для корректной расшифровки текст должен состоять хотя бы из нескольких слов.*

----

